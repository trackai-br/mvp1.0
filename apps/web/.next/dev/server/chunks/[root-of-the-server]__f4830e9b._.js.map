{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/guilhermesimas/Documents/hub-server-side-tracking/apps/web/src/lib/server/setup-store.ts"],"sourcesContent":["import type { SetupSessionCreateInput, SetupSessionStatus } from '@hub/shared';\n\nconst sessions = new Map<string, SetupSessionStatus>();\n\nfunction generateToken() {\n  return crypto.randomUUID().replace(/-/g, '');\n}\n\nfunction buildWebhookData(input: {\n  requestOrigin: string;\n  sessionId: string;\n  token: string;\n}) {\n  const path = `/api/v1/webhooks/perfectpay/${input.sessionId}/${input.token}`;\n  return {\n    provider: 'perfectpay' as const,\n    path,\n    url: `${input.requestOrigin}${path}`,\n    token: input.token\n  };\n}\n\nexport function createSetupSession(input: {\n  payload: SetupSessionCreateInput;\n  requestOrigin: string;\n}): SetupSessionStatus {\n  const now = new Date().toISOString();\n  const id = crypto.randomUUID();\n  const token = generateToken();\n\n  const session: SetupSessionStatus = {\n    id,\n    projectName: input.payload.projectName,\n    state: 'created',\n    createdAt: now,\n    updatedAt: now,\n    input: input.payload,\n    webhook: buildWebhookData({\n      requestOrigin: input.requestOrigin,\n      sessionId: id,\n      token\n    }),\n    checks: {\n      gatewayCredentials: 'pending',\n      metaToken: 'pending',\n      landingProbe: 'pending'\n    },\n    issues: []\n  };\n\n  sessions.set(id, session);\n  return session;\n}\n\nexport function getSetupSession(id: string): SetupSessionStatus | null {\n  return sessions.get(id) ?? null;\n}\n\nexport function saveSetupSession(session: SetupSessionStatus): void {\n  session.updatedAt = new Date().toISOString();\n  sessions.set(session.id, session);\n}\n"],"names":[],"mappings":";;;;;;;;AAEA,MAAM,WAAW,IAAI;AAErB,SAAS;IACP,OAAO,OAAO,UAAU,GAAG,OAAO,CAAC,MAAM;AAC3C;AAEA,SAAS,iBAAiB,KAIzB;IACC,MAAM,OAAO,CAAC,4BAA4B,EAAE,MAAM,SAAS,CAAC,CAAC,EAAE,MAAM,KAAK,EAAE;IAC5E,OAAO;QACL,UAAU;QACV;QACA,KAAK,GAAG,MAAM,aAAa,GAAG,MAAM;QACpC,OAAO,MAAM,KAAK;IACpB;AACF;AAEO,SAAS,mBAAmB,KAGlC;IACC,MAAM,MAAM,IAAI,OAAO,WAAW;IAClC,MAAM,KAAK,OAAO,UAAU;IAC5B,MAAM,QAAQ;IAEd,MAAM,UAA8B;QAClC;QACA,aAAa,MAAM,OAAO,CAAC,WAAW;QACtC,OAAO;QACP,WAAW;QACX,WAAW;QACX,OAAO,MAAM,OAAO;QACpB,SAAS,iBAAiB;YACxB,eAAe,MAAM,aAAa;YAClC,WAAW;YACX;QACF;QACA,QAAQ;YACN,oBAAoB;YACpB,WAAW;YACX,cAAc;QAChB;QACA,QAAQ,EAAE;IACZ;IAEA,SAAS,GAAG,CAAC,IAAI;IACjB,OAAO;AACT;AAEO,SAAS,gBAAgB,EAAU;IACxC,OAAO,SAAS,GAAG,CAAC,OAAO;AAC7B;AAEO,SAAS,iBAAiB,OAA2B;IAC1D,QAAQ,SAAS,GAAG,IAAI,OAAO,WAAW;IAC1C,SAAS,GAAG,CAAC,QAAQ,EAAE,EAAE;AAC3B"}},
    {"offset": {"line": 104, "column": 0}, "map": {"version":3,"sources":["file:///Users/guilhermesimas/Documents/hub-server-side-tracking/apps/web/src/lib/server/validation.ts"],"sourcesContent":["import type { SetupSessionStatus } from '@hub/shared';\n\nconst GRAPH_BASE = process.env.META_GRAPH_API_BASE ?? 'https://graph.facebook.com/v21.0';\nconst PERFECTPAY_BASE = process.env.PERFECTPAY_API_BASE ?? 'https://app.perfectpay.com.br';\nconst PERFECTPAY_VALIDATE_PATH = process.env.PERFECTPAY_VALIDATE_PATH ?? '/api/v1/sales/get';\n\nasync function validateMetaToken(input: {\n  pixelId: string;\n  accessToken: string;\n}): Promise<{ ok: boolean; message?: string }> {\n  const url = new URL(`${GRAPH_BASE}/${input.pixelId}`);\n  url.searchParams.set('fields', 'id');\n  url.searchParams.set('access_token', input.accessToken);\n\n  try {\n    const response = await fetch(url.toString(), { method: 'GET' });\n    const data = (await response.json().catch(() => null)) as\n      | { id?: string; error?: { message?: string } }\n      | null;\n\n    if (!response.ok) {\n      return {\n        ok: false,\n        message: data?.error?.message ?? `Meta API retornou ${response.status}`\n      };\n    }\n\n    return data?.id ? { ok: true } : { ok: false, message: 'Pixel nao encontrado.' };\n  } catch (error) {\n    return {\n      ok: false,\n      message: error instanceof Error ? error.message : 'Erro de rede ao validar Meta.'\n    };\n  }\n}\n\nasync function validatePerfectPay(input: {\n  apiKey: string;\n}): Promise<{ ok: boolean; message?: string }> {\n  const endpoint = `${PERFECTPAY_BASE}${PERFECTPAY_VALIDATE_PATH}`;\n\n  try {\n    const response = await fetch(endpoint, {\n      method: 'POST',\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${input.apiKey}`\n      },\n      body: JSON.stringify({ page: 1 })\n    });\n\n    const data = (await response.json().catch(() => null)) as\n      | { message?: string; error?: { message?: string } }\n      | null;\n\n    if (!response.ok) {\n      return {\n        ok: false,\n        message: data?.error?.message ?? data?.message ?? `Perfect Pay retornou ${response.status}`\n      };\n    }\n\n    return { ok: true };\n  } catch (error) {\n    return {\n      ok: false,\n      message: error instanceof Error ? error.message : 'Erro de rede ao validar Perfect Pay.'\n    };\n  }\n}\n\nexport async function runValidations(session: SetupSessionStatus): Promise<SetupSessionStatus> {\n  const issues: string[] = [];\n\n  const perfectPayResult = await validatePerfectPay({ apiKey: session.input.gateway.apiKey });\n  const webhookOk = session.input.gateway.webhookSecret.trim().length >= 8;\n  const gatewayOk = perfectPayResult.ok && webhookOk;\n\n  const metaResult = await validateMetaToken({\n    pixelId: session.input.meta.pixelId,\n    accessToken: session.input.meta.accessToken\n  });\n\n  const landingOk = /^https?:\\/\\//.test(session.input.landingUrl);\n\n  session.checks.gatewayCredentials = gatewayOk ? 'ok' : 'failed';\n  session.checks.metaToken = metaResult.ok ? 'ok' : 'failed';\n  session.checks.landingProbe = landingOk ? 'ok' : 'failed';\n\n  if (!gatewayOk) {\n    issues.push(\n      `Falha na validacao de credenciais da Perfect Pay${\n        perfectPayResult.message ? `: ${perfectPayResult.message}` : '.'\n      }`\n    );\n  }\n  if (!metaResult.ok) {\n    issues.push(\n      `Falha na validacao do token/pixel Meta${metaResult.message ? `: ${metaResult.message}` : '.'}`\n    );\n  }\n  if (!landingOk) {\n    issues.push('Falha no probe da URL da landing page.');\n  }\n\n  session.issues = issues;\n  session.state = issues.length === 0 ? 'validated' : 'troubleshooting_required';\n  return session;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["file:///Users/guilhermesimas/Documents/hub-server-side-tracking/apps/web/src/app/api/v1/setup/sessions/%5Bid%5D/validate/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { getSetupSession, saveSetupSession } from '@/lib/server/setup-store';\nimport { runValidations } from '@/lib/server/validation';\n\nexport const runtime = 'nodejs';\n\nexport async function POST(\n  _request: Request,\n  context: { params: Promise<{ id: string }> }\n) {\n  const { id } = await context.params;\n  const session = getSetupSession(id);\n\n  if (!session) {\n    return NextResponse.json({ message: 'Setup session nao encontrada.' }, { status: 404 });\n  }\n\n  const validated = await runValidations(session);\n  saveSetupSession(validated);\n\n  return NextResponse.json(validated);\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAEO,MAAM,UAAU;AAEhB,eAAe,KACpB,QAAiB,EACjB,OAA4C;IAE5C,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,QAAQ,MAAM;IACnC,MAAM,UAAU,IAAA,0KAAe,EAAC;IAEhC,IAAI,CAAC,SAAS;QACZ,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAgC,GAAG;YAAE,QAAQ;QAAI;IACvF;IAEA,MAAM,YAAY,MAAM,IAAA,qKAAc,EAAC;IACvC,IAAA,2KAAgB,EAAC;IAEjB,OAAO,gJAAY,CAAC,IAAI,CAAC;AAC3B"}}]
}